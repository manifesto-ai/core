/**
 * BabyAI Domain - Grid World Navigation
 *
 * A MEL domain definition for BabyAI benchmark tasks.
 *
 * Actions:
 * - turnLeft/turnRight: Pure state patches (direction rotation)
 * - moveForward/pickup/drop/toggle: Effects (require collision/validation)
 * - done: Signal task completion
 */

domain BabyAI {
  // ===========================================================================
  // Named Types
  // ===========================================================================

  type CarriedObject = {
    kind: string,
    color: string
  }

  type WorldObject = {
    id: string,
    kind: string,
    color: string,
    x: number,
    y: number,
    isOpen: boolean | null
  }

  type Agent = {
    x: number,
    y: number,
    direction: number,
    carrying: CarriedObject | null
  }

  type Grid = {
    width: number,
    height: number,
    cells: Array<Array<string>>
  }

  // ===========================================================================
  // State
  // ===========================================================================

  state {
    // Grid world
    grid: Grid = { width: 8, height: 8, cells: [] }

    // Agent state
    agent: Agent = { x: 0, y: 0, direction: 0, carrying: null }

    // World objects (keys, balls, boxes, doors)
    objects: Array<WorldObject> = []

    // Mission description
    mission: string = ""

    // Step tracking
    steps: number = 0
    maxSteps: number = 100

    // Goal status
    goalReached: boolean = false

    // Re-entry markers for idempotent effects
    lastMoveIntent: string | null = null
    lastPickupIntent: string | null = null
    lastDropIntent: string | null = null
    lastToggleIntent: string | null = null
  }

  // ===========================================================================
  // Computed Values
  // ===========================================================================

  // Can pickup: not currently carrying anything
  computed canPickup = isNull(agent.carrying)

  // Can drop: currently carrying something
  computed canDrop = isNotNull(agent.carrying)

  // Steps remaining
  computed stepsRemaining = sub(maxSteps, steps)

  // Is at step limit
  computed isAtLimit = gte(steps, maxSteps)

  // ===========================================================================
  // Actions
  // ===========================================================================

  /**
   * Turn left - rotate direction counter-clockwise
   * Direction: 0=East, 1=South, 2=West, 3=North
   * (direction + 3) % 4
   */
  action turnLeft() {
    when not(goalReached) {
      patch agent.direction = mod(add(agent.direction, 3), 4)
      patch steps = add(steps, 1)
    }
  }

  /**
   * Turn right - rotate direction clockwise
   * (direction + 1) % 4
   */
  action turnRight() {
    when not(goalReached) {
      patch agent.direction = mod(add(agent.direction, 1), 4)
      patch steps = add(steps, 1)
    }
  }

  /**
   * Move forward - requires collision detection
   * Effect checks walkability and updates position
   */
  action moveForward() {
    once(lastMoveIntent) when not(goalReached) {
      patch lastMoveIntent = $meta.intentId

      effect babyai.move({
        x: agent.x,
        y: agent.y,
        direction: agent.direction
      })
    }
  }

  /**
   * Pickup object in front
   * Effect validates object existence and updates carrying
   */
  action pickup() available when canPickup {
    once(lastPickupIntent) when not(goalReached) {
      patch lastPickupIntent = $meta.intentId

      effect babyai.pickup({
        x: agent.x,
        y: agent.y,
        direction: agent.direction
      })
    }
  }

  /**
   * Drop carried object in front
   * Effect validates position and creates new object
   */
  action drop() available when canDrop {
    once(lastDropIntent) when not(goalReached) {
      patch lastDropIntent = $meta.intentId

      effect babyai.drop({
        x: agent.x,
        y: agent.y,
        direction: agent.direction,
        carrying: agent.carrying
      })
    }
  }

  /**
   * Toggle door in front (open/close)
   * Effect finds door and toggles isOpen
   */
  action toggle() {
    once(lastToggleIntent) when not(goalReached) {
      patch lastToggleIntent = $meta.intentId

      effect babyai.toggle({
        x: agent.x,
        y: agent.y,
        direction: agent.direction
      })
    }
  }

  /**
   * Mark goal as reached - task complete
   */
  action done() {
    when not(goalReached) {
      patch goalReached = true
    }
  }
}
