# Code Generation

> **Purpose:** Generate type-safe TypeScript and Zod code from your DomainSchema
> **Audience:** Developers who have a working Manifesto schema
> **Reading time:** 10-15 minutes

---

## Overview

`@manifesto-ai/codegen` takes a DomainSchema and produces:

- **TypeScript types** -- `export interface` and `export type` definitions
- **Zod schemas** -- Runtime validators with `z.ZodType<T>` annotations

The output is deterministic: same schema always produces byte-identical files. Generated files include a `@generated` header and should not be hand-edited.

```
DomainSchema ──> [ TS Plugin ] ──> types.ts
                 [ Zod Plugin ] ──> base.ts
```

---

## Installation

```bash
pnpm add @manifesto-ai/codegen
# Peer dependency
pnpm add @manifesto-ai/core
```

---

## Quick Start

```typescript
import { generate, createTsPlugin, createZodPlugin } from "@manifesto-ai/codegen";
import type { DomainSchema } from "@manifesto-ai/core";

const schema: DomainSchema = {
  id: "example:app",
  version: "1.0.0",
  hash: "...",
  types: {
    Todo: {
      name: "Todo",
      definition: {
        kind: "object",
        fields: {
          id: { type: { kind: "primitive", type: "string" }, optional: false },
          title: { type: { kind: "primitive", type: "string" }, optional: false },
          done: { type: { kind: "primitive", type: "boolean" }, optional: false },
        },
      },
    },
  },
  state: { fields: {} },
  computed: { fields: {} },
  actions: {},
};

const result = await generate({
  schema,
  outDir: "./generated",
  plugins: [createTsPlugin(), createZodPlugin()],
});

console.log(result.files.map(f => f.path));
// -> ["types.ts", "base.ts"]
```

**Generated types.ts:**

```typescript
// @generated by @manifesto-ai/codegen — DO NOT EDIT
export interface Todo {
  done: boolean;
  id: string;
  title: string;
}
```

**Generated base.ts:**

```typescript
// @generated by @manifesto-ai/codegen — DO NOT EDIT
import { z } from "zod";
import type { Todo } from "./types";

export const TodoSchema: z.ZodType<Todo> = z.object({
  done: z.boolean(),
  id: z.string(),
  title: z.string(),
});
```

---

## Common Scenarios

### TypeScript Only

If you only need type definitions without Zod:

```typescript
const result = await generate({
  schema,
  outDir: "./generated",
  plugins: [createTsPlugin()],
});
// Produces only types.ts
```

### Custom File Names

```typescript
const result = await generate({
  schema,
  outDir: "./generated",
  plugins: [
    createTsPlugin({ typesFile: "domain-types.ts" }),
    createZodPlugin({ schemasFile: "validators.ts" }),
  ],
});
// Produces domain-types.ts + validators.ts
```

### Handling Errors

When an error occurs (e.g., file collision), no files are written to disk:

```typescript
const result = await generate({ schema, outDir, plugins });

const errors = result.diagnostics.filter(d => d.level === "error");
if (errors.length > 0) {
  errors.forEach(e => console.error(`[${e.plugin}] ${e.message}`));
  // No files were written to disk
}
```

---

## Type Mapping Reference

| Schema Definition | TypeScript | Zod |
|-------------------|-----------|-----|
| `{ kind: "primitive", type: "string" }` | `string` | `z.string()` |
| `{ kind: "literal", value: "active" }` | `"active"` | `z.literal("active")` |
| `{ kind: "array", element: T }` | `T[]` | `z.array(T)` |
| `{ kind: "record", key: K, value: V }` | `Record<K, V>` | `z.record(K, V)` |
| `{ kind: "object", fields: {...} }` | `export interface` | `z.object({...})` |
| `{ kind: "union", types: [A, B] }` | `A \| B` | `z.union([A, B])` |
| Union with null (`T \| null`) | `T \| null` | `z.nullable(T)` |
| `{ kind: "ref", name: "Other" }` | `Other` | `z.lazy(() => OtherSchema)` |
| Optional field | `field?: T` | `.optional()` |

---

## CI Integration

Add codegen to your build pipeline and verify no drift:

```bash
# Generate
pnpm exec codegen --schema ./schema.json --outDir ./generated

# Verify (fails if generated files changed)
pnpm exec codegen --schema ./schema.json --outDir ./generated
git diff --exit-code ./generated/
```

This ensures generated code is always committed and up-to-date.

---

## Plugin Order Matters

Plugins run in array order. The Zod plugin reads artifacts from the TS plugin to generate type annotations:

```typescript
// Correct: TS first, then Zod
plugins: [createTsPlugin(), createZodPlugin()]

// Also valid: Zod alone (no type annotations, but functional)
plugins: [createZodPlugin()]
```

When the Zod plugin runs without the TS plugin, it produces schemas without `z.ZodType<T>` annotations -- still valid for runtime validation, but without compile-time type checking.

---

## Common Mistakes

### File Name Collision

```typescript
// Wrong: both plugins write to the same file
plugins: [
  createTsPlugin({ typesFile: "output.ts" }),
  createZodPlugin({ schemasFile: "output.ts" }),
]
// -> Error diagnostic, no files written
```

**Fix:** Use distinct file names for each plugin.

### Absolute or Traversal Paths

```typescript
// Wrong: in a custom plugin
patches: [{ op: "set", path: "/etc/types.ts", content: "..." }]  // absolute
patches: [{ op: "set", path: "../escape.ts", content: "..." }]   // traversal
```

**Fix:** Use relative paths that stay within the output directory.

---

## Next Steps

- **[API Reference](/api/codegen)** -- Complete API documentation
- **[Package GUIDE](https://github.com/manifesto-ai/core/blob/main/packages/codegen/docs/GUIDE.md)** -- Custom plugin tutorial and advanced usage
- **[SPEC-v0.1.1](https://github.com/manifesto-ai/core/blob/main/packages/codegen/docs/SPEC-v0.1.1.md)** -- Normative specification with all rule IDs

---

## See Also

- **[Tutorial](/tutorial/)** -- Learn Manifesto from scratch
- **[@manifesto-ai/core API](/api/core)** -- DomainSchema and TypeDefinition types
- **[@manifesto-ai/compiler API](/api/compiler)** -- Compile MEL to DomainSchema
