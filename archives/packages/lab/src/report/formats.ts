/**
 * Report Formats
 *
 * Output format generators for Lab reports.
 * Added in v1.1.
 */

import * as fs from "node:fs";
import type {
  LabReport,
  EnhancedLabReport,
  ReportJSON,
  TimelineEntry,
  LabTraceEvent,
  FailureReason,
  FailureExplanation,
} from "../types.js";

// =============================================================================
// Enhanced Report Factory
// =============================================================================

/**
 * Enhance a LabReport with output format methods.
 *
 * @param report - The base lab report
 * @returns Enhanced report with format methods
 */
export function enhanceReport(report: LabReport): EnhancedLabReport {
  return {
    ...report,
    toMarkdown: () => toMarkdown(report),
    toMarkdownFile: (path: string) => toMarkdownFile(report, path),
    toHTML: () => toHTML(report),
    toHTMLFile: (path: string) => toHTMLFile(report, path),
    toJSON: () => toReportJSON(report),
  };
}

// =============================================================================
// Markdown Output
// =============================================================================

/**
 * Convert report to Markdown string.
 */
export function toMarkdown(report: LabReport): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Lab Report: ${report.runId}`);
  lines.push("");

  // Meta section
  lines.push("## Overview");
  lines.push("");
  lines.push(`| Property | Value |`);
  lines.push(`|----------|-------|`);
  lines.push(`| Run ID | \`${report.runId}\` |`);
  lines.push(`| Necessity Level | ${report.necessityLevel} |`);
  lines.push(`| Outcome | **${report.outcome}** |`);
  lines.push(`| Started | ${report.startedAt} |`);
  lines.push(`| Completed | ${report.completedAt} |`);
  lines.push(`| Duration | ${formatDuration(report.duration)} |`);
  lines.push("");

  // Summary section
  lines.push("## Summary");
  lines.push("");
  lines.push(`| Metric | Count |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Total Proposals | ${report.summary.totalProposals} |`);
  lines.push(`| Approved | ${report.summary.approvedProposals} |`);
  lines.push(`| Rejected | ${report.summary.rejectedProposals} |`);
  lines.push(`| HITL Interventions | ${report.summary.hitlInterventions} |`);
  lines.push(`| Patches Applied | ${report.summary.totalPatches} |`);
  lines.push(`| Effects Executed | ${report.summary.totalEffects} |`);
  lines.push(`| Worlds Created | ${report.summary.worldsCreated} |`);
  lines.push("");

  // Failure section
  if (report.outcome === "failure" && report.failureExplanation) {
    lines.push("## Failure Analysis");
    lines.push("");
    lines.push(`**Kind:** \`${report.failureExplanation.kind}\``);
    lines.push("");
    lines.push(`**Title:** ${report.failureExplanation.title}`);
    lines.push("");
    lines.push(`**Description:** ${report.failureExplanation.description}`);
    lines.push("");

    if (report.failureExplanation.counterfactual) {
      lines.push("### What Could Have Prevented This");
      lines.push("");
      const cf = report.failureExplanation.counterfactual;
      lines.push(`Change: ${cf.change.type} (Expected: ${cf.expectedOutcome}, Confidence: ${cf.confidence})`);
      lines.push("");
    }
  }

  // Timeline section
  lines.push("## Event Timeline");
  lines.push("");

  const timeline = buildTimeline(report.trace.events);
  if (timeline.length > 0) {
    lines.push("| Seq | Time | Event | Details |");
    lines.push("|-----|------|-------|---------|");

    for (const entry of timeline) {
      const details = [entry.actor, entry.result, entry.note]
        .filter(Boolean)
        .join(", ");
      lines.push(`| ${entry.seq} | ${formatTimestamp(entry.timestamp)} | ${entry.event} | ${details || "-"} |`);
    }
    lines.push("");
  } else {
    lines.push("*No events recorded*");
    lines.push("");
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(`*Generated by @manifesto-ai/lab v1.1*`);

  return lines.join("\n");
}

/**
 * Save Markdown to file.
 */
export async function toMarkdownFile(
  report: LabReport,
  path: string
): Promise<void> {
  const content = toMarkdown(report);
  await fs.promises.writeFile(path, content, "utf-8");
}

// =============================================================================
// HTML Output
// =============================================================================

/**
 * Convert report to HTML string.
 */
export function toHTML(report: LabReport): string {
  const outcomeClass =
    report.outcome === "success" ? "success" : report.outcome === "failure" ? "failure" : "aborted";

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab Report: ${escapeHtml(report.runId)}</title>
  <style>
    :root {
      --success-color: #22c55e;
      --failure-color: #ef4444;
      --aborted-color: #f59e0b;
      --border-color: #e5e7eb;
      --bg-color: #f9fafb;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
    }
    h1, h2, h3 { margin-top: 2rem; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    th, td {
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      text-align: left;
    }
    th { background: var(--bg-color); }
    .outcome {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.875rem;
    }
    .outcome.success { background: #dcfce7; color: #166534; }
    .outcome.failure { background: #fee2e2; color: #991b1b; }
    .outcome.aborted { background: #fef3c7; color: #92400e; }
    .timeline { font-size: 0.875rem; }
    .code { font-family: 'Monaco', 'Consolas', monospace; background: var(--bg-color); padding: 0.125rem 0.375rem; border-radius: 0.25rem; }
    .failure-box { background: #fee2e2; border: 1px solid #fecaca; padding: 1rem; border-radius: 0.5rem; margin: 1rem 0; }
    footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid var(--border-color); font-size: 0.875rem; color: #6b7280; }
  </style>
</head>
<body>
  <h1>Lab Report: <span class="code">${escapeHtml(report.runId)}</span></h1>

  <h2>Overview</h2>
  <table>
    <tr><th>Property</th><th>Value</th></tr>
    <tr><td>Run ID</td><td><span class="code">${escapeHtml(report.runId)}</span></td></tr>
    <tr><td>Necessity Level</td><td>${report.necessityLevel}</td></tr>
    <tr><td>Outcome</td><td><span class="outcome ${outcomeClass}">${report.outcome}</span></td></tr>
    <tr><td>Started</td><td>${escapeHtml(report.startedAt)}</td></tr>
    <tr><td>Completed</td><td>${escapeHtml(report.completedAt)}</td></tr>
    <tr><td>Duration</td><td>${formatDuration(report.duration)}</td></tr>
  </table>

  <h2>Summary</h2>
  <table>
    <tr><th>Metric</th><th>Count</th></tr>
    <tr><td>Total Proposals</td><td>${report.summary.totalProposals}</td></tr>
    <tr><td>Approved</td><td>${report.summary.approvedProposals}</td></tr>
    <tr><td>Rejected</td><td>${report.summary.rejectedProposals}</td></tr>
    <tr><td>HITL Interventions</td><td>${report.summary.hitlInterventions}</td></tr>
    <tr><td>Patches Applied</td><td>${report.summary.totalPatches}</td></tr>
    <tr><td>Effects Executed</td><td>${report.summary.totalEffects}</td></tr>
    <tr><td>Worlds Created</td><td>${report.summary.worldsCreated}</td></tr>
  </table>

  ${
    report.outcome === "failure" && report.failureExplanation
      ? `
  <h2>Failure Analysis</h2>
  <div class="failure-box">
    <p><strong>Kind:</strong> <span class="code">${escapeHtml(report.failureExplanation.kind)}</span></p>
    <p><strong>Title:</strong> ${escapeHtml(report.failureExplanation.title)}</p>
    <p><strong>Description:</strong> ${escapeHtml(report.failureExplanation.description)}</p>
    ${
      report.failureExplanation.counterfactual
        ? `<p><strong>What Could Have Prevented This:</strong> ${escapeHtml(`${report.failureExplanation.counterfactual.change.type} (Expected: ${report.failureExplanation.counterfactual.expectedOutcome})`)}</p>`
        : ""
    }
  </div>
  `
      : ""
  }

  <h2>Event Timeline</h2>
  ${buildTimelineHTML(report.trace.events)}

  <footer>
    Generated by @manifesto-ai/lab v1.1
  </footer>
</body>
</html>`;
}

/**
 * Build HTML timeline table.
 */
function buildTimelineHTML(events: LabTraceEvent[]): string {
  const timeline = buildTimeline(events);

  if (timeline.length === 0) {
    return "<p><em>No events recorded</em></p>";
  }

  const rows = timeline
    .map(
      (entry) => `
    <tr>
      <td>${entry.seq}</td>
      <td>${formatTimestamp(entry.timestamp)}</td>
      <td>${escapeHtml(entry.event)}</td>
      <td>${escapeHtml([entry.actor, entry.result, entry.note].filter(Boolean).join(", ") || "-")}</td>
    </tr>`
    )
    .join("\n");

  return `
  <table class="timeline">
    <tr>
      <th>Seq</th>
      <th>Time</th>
      <th>Event</th>
      <th>Details</th>
    </tr>
    ${rows}
  </table>`;
}

/**
 * Save HTML to file.
 */
export async function toHTMLFile(
  report: LabReport,
  path: string
): Promise<void> {
  const content = toHTML(report);
  await fs.promises.writeFile(path, content, "utf-8");
}

// =============================================================================
// JSON Output
// =============================================================================

/**
 * Map FailureExplanation.kind to FailureReason.
 */
function kindToReason(kind: FailureExplanation["kind"]): FailureReason {
  switch (kind) {
    case "structural":
      return "NO_EXECUTABLE_ACTION";
    case "informational":
      return "GOAL_UNREACHABLE";
    case "governance":
      return "AUTHORITY_REJECTION";
    case "human_required":
      return "HUMAN_REQUIRED";
    case "resource":
      return "RESOURCE_EXHAUSTED";
    default:
      return "GOAL_UNREACHABLE";
  }
}

/**
 * Convert report to structured JSON format.
 */
export function toReportJSON(report: LabReport): ReportJSON {
  return {
    meta: {
      runId: report.runId,
      level: report.necessityLevel,
      outcome: report.outcome as "success" | "failure" | "aborted",
      duration: formatDuration(report.duration),
      createdAt: report.startedAt,
    },
    summary: {
      totalSteps: report.summary.totalProposals,
      proposals: report.summary.totalProposals,
      approvals: report.summary.approvedProposals,
      rejections: report.summary.rejectedProposals,
      hitlInterventions: report.summary.hitlInterventions,
    },
    failure: report.failureExplanation
      ? {
          reason: kindToReason(report.failureExplanation.kind),
          explanation: report.failureExplanation.description,
          counterfactual: report.failureExplanation.counterfactual
            ? `${report.failureExplanation.counterfactual.change.type} (Expected: ${report.failureExplanation.counterfactual.expectedOutcome})`
            : undefined,
        }
      : undefined,
    timeline: buildTimeline(report.trace.events),
  };
}

// =============================================================================
// Helpers
// =============================================================================

/**
 * Build timeline from events.
 */
function buildTimeline(events: LabTraceEvent[]): TimelineEntry[] {
  return events.map((event) => {
    const entry: TimelineEntry = {
      seq: event.seq,
      timestamp: event.timestamp,
      event: event.type,
    };

    switch (event.type) {
      case "proposal":
        entry.actor = event.actorId;
        entry.note = event.intentType;
        break;
      case "authority.decision":
        entry.result = event.decision;
        entry.note = event.authorityId;
        break;
      case "hitl":
        entry.result = event.action;
        entry.actor = event.decidedBy;
        break;
      case "termination":
        entry.result = event.outcome;
        break;
      case "apply":
        entry.note = `${event.patchCount} patches`;
        break;
      case "effect":
        entry.note = event.effectType;
        break;
      case "effect.result":
        entry.result = event.success ? "success" : "failure";
        break;
    }

    return entry;
  });
}

/**
 * Format duration in human-readable format.
 */
function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  return `${minutes}m ${seconds}s`;
}

/**
 * Format timestamp for display.
 */
function formatTimestamp(ts: string): string {
  try {
    const date = new Date(ts);
    return date.toISOString().replace("T", " ").replace("Z", "").slice(0, 19);
  } catch {
    return ts;
  }
}

/**
 * Escape HTML special characters.
 */
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
