// Translator Domain Definition
// Manifesto Translator SPEC v2.0
// MEL v0.3.3

import { Token, GlossaryHit } from "@manifesto/core"
import { PatchFragment } from "@manifesto/translator-types"

domain Translator {

  // ===========================================================================
  // Types
  // ===========================================================================

  type TranslationOptions = {
    language: string | null
    maxCandidates: number
    timeoutMs: number
    fallbackBehavior: "guess" | "discard"
  }

  type TranslationRequest = {
    input: string
    targetSchemaId: string
    intentId: string
    options: TranslationOptions
  }

  type ProtectedSpan = {
    start: number
    end: number
    kind: "identifier" | "number" | "literal" | "operator"
    value: string
  }

  type NormalizationResult = {
    canonical: string
    language: string
    tokens: Array<Token>
    glossaryHits: Array<GlossaryHit>
    protected: Array<ProtectedSpan>
  }

  type FastPathResult = {
    matched: boolean
    pattern: string | null
    fragment: PatchFragment | null
    confidence: number
  }

  type AnchorCandidate = {
    path: string
    score: number
    matchType: "exact" | "alias" | "fuzzy" | "semantic"
  }

  type RetrievalResult = {
    tier: number
    candidates: Array<AnchorCandidate>
    queryTerms: Array<string>
  }

  type ResolutionOption = {
    id: string
    label: string
    fragment: PatchFragment
    confidence: number
  }

  type AmbiguityReport = {
    kind: "anchor" | "intent" | "value" | "conflict"
    question: string
    options: Array<ResolutionOption>
    fallbackBehavior: "guess" | "discard"
    expiresAt: number | null
  }

  type ProposalResult = {
    fragment: PatchFragment | null
    ambiguity: AmbiguityReport | null
    confidence: number
    reasoning: string | null
  }

  type TranslationResultFragment = {
    kind: "fragment"
    fragment: PatchFragment
  }

  type TranslationResultDiscarded = {
    kind: "discarded"
    reason: string
  }

  type ResolutionSelection = {
    decision: "select" | "discard" | "freeform"
    optionId: string | null
    freeformInput: string | null
  }

  // ===========================================================================
  // State
  // ===========================================================================

  state {
    request: TranslationRequest | null = null
    normalization: NormalizationResult | null = null
    fastPath: FastPathResult | null = null
    retrieval: RetrievalResult | null = null
    proposal: ProposalResult | null = null
    result: TranslationResultFragment | TranslationResultDiscarded | null = null

    initializing: string | null = null
    normalizing: string | null = null
    fastPathing: string | null = null
    retrieving: string | null = null
    proposing: string | null = null
    resolving: string | null = null
    resetting: string | null = null
  }

  // ===========================================================================
  // Computed
  // ===========================================================================

  computed hasRequest = isNotNull(request)
  computed isNormalized = isNotNull(normalization)
  computed hasFastPath = isNotNull(fastPath)
  computed hasRetrieval = isNotNull(retrieval)
  computed hasProposal = isNotNull(proposal)
  computed isComplete = isNotNull(result)

  computed fastPathSucceeded = and(hasFastPath, fastPath.matched)
  computed needsSlm = and(hasFastPath, not(fastPath.matched))

  computed needsResolution = and(
    hasProposal,
    isNotNull(proposal.ambiguity),
    isNull(result)
  )

  computed resolutionExpired = and(
    needsResolution,
    isNotNull(proposal.ambiguity.expiresAt),
    gte($meta.timestamp, proposal.ambiguity.expiresAt)
  )

  computed currentStage = cond(
    not(hasRequest), "idle",
    cond(not(isNormalized), "normalizing",
    cond(not(hasFastPath), "fast-path",
    cond(and(needsSlm, not(hasRetrieval)), "retrieving",
    cond(and(needsSlm, not(hasProposal)), "proposing",
    cond(needsResolution, "awaiting-resolution",
    "complete"))))))

  computed progress = cond(
    not(hasRequest), 0.0,
    cond(not(isNormalized), 0.2,
    cond(not(hasFastPath), 0.4,
    cond(fastPathSucceeded, 1.0,
    cond(not(hasRetrieval), 0.6,
    cond(not(hasProposal), 0.8,
    1.0))))))

  // ===========================================================================
  // Actions
  // ===========================================================================

  action translate(input: string, schemaId: string, options: TranslationOptions | null)
    available when not(hasRequest) {

    once(initializing) {
      patch initializing = $meta.intentId
      patch request = {
        input: input,
        targetSchemaId: schemaId,
        intentId: $meta.intentId,
        options: coalesce(options, {
          language: null,
          maxCandidates: 5,
          timeoutMs: 300000,
          fallbackBehavior: "guess"
        })
      }
    }

    once(normalizing) when hasRequest {
      patch normalizing = $meta.intentId
      effect llm.normalize({
        protocol: "translator.normalize",
        input: { text: request.input, languageHint: request.options.language },
        into: normalization
      })
    }

    once(fastPathing) when isNormalized {
      patch fastPathing = $meta.intentId
      effect translator.fastPath({
        canonical: normalization.canonical,
        tokens: normalization.tokens,
        glossaryHits: normalization.glossaryHits,
        schemaId: request.targetSchemaId,
        into: fastPath
      })
    }

    when and(isNull(result), fastPathSucceeded) {
      patch result = { kind: "fragment", fragment: fastPath.fragment }
    }

    once(retrieving) when needsSlm {
      patch retrieving = $meta.intentId
      effect translator.retrieve({
        terms: normalization.tokens,
        glossaryHits: normalization.glossaryHits,
        schemaId: request.targetSchemaId,
        maxCandidates: request.options.maxCandidates,
        into: retrieval
      })
    }

    once(proposing) when hasRetrieval {
      patch proposing = $meta.intentId
      effect llm.propose({
        protocol: "translator.propose",
        input: {
          canonical: normalization.canonical,
          tokens: normalization.tokens,
          candidates: retrieval.candidates,
          schemaId: request.targetSchemaId,
          timeoutMs: request.options.timeoutMs,
          fallbackBehavior: request.options.fallbackBehavior
        },
        into: proposal
      })
    }

    when and(isNull(result), hasProposal, isNull(proposal.ambiguity)) {
      patch result = { kind: "fragment", fragment: proposal.fragment }
    }

    when resolutionExpired {
      patch result = cond(
        eq(request.options.fallbackBehavior, "guess"),
        { kind: "fragment", fragment: proposal.ambiguity.options[0].fragment },
        { kind: "discarded", reason: "resolution timeout" }
      )
    }
  }

  action resolve(selection: ResolutionSelection)
    available when needsResolution {

    once(resolving) {
      patch resolving = $meta.intentId

      when eq(selection.decision, "select") {
        patch result = {
          kind: "fragment",
          fragment: findOption(proposal.ambiguity.options, selection.optionId).fragment
        }
      }

      when eq(selection.decision, "discard") {
        patch result = { kind: "discarded", reason: "user rejected" }
      }

      when eq(selection.decision, "freeform") {
        patch request = {
          input: selection.freeformInput,
          targetSchemaId: request.targetSchemaId,
          intentId: $meta.intentId,
          options: request.options
        }
        patch normalization = null
        patch fastPath = null
        patch retrieval = null
        patch proposal = null
        patch initializing = null
        patch normalizing = null
        patch fastPathing = null
        patch retrieving = null
        patch proposing = null
      }
    }
  }

  action reset()
    available when isComplete {

    once(resetting) {
      patch resetting = $meta.intentId
      patch request = null
      patch normalization = null
      patch fastPath = null
      patch retrieval = null
      patch proposal = null
      patch result = null
      patch initializing = null
      patch normalizing = null
      patch fastPathing = null
      patch retrieving = null
      patch proposing = null
      patch resolving = null
    }
  }
}
