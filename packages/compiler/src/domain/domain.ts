/**
 * @manifesto-ai/compiler v1.1 Domain
 *
 * CompilerDomain - Manifesto Application for the Fragment Pipeline architecture.
 *
 * Per FDR-C001: Compiler MUST be implemented as a Manifesto Application (dogfooding).
 * Per SPEC_1.1v §7: State machine with Plan → Generate → Lower → Link → Verify → Emit pipeline.
 *
 * NOTE: This domain uses `as never` casts liberally due to complex type interactions
 * between Zod schemas, Builder expressions, and the state machine. The runtime behavior
 * is correct; the casts work around TypeScript limitations with builder DSL types.
 */

import { z } from "zod";
import { defineDomain } from "@manifesto-ai/builder";
import {
  CompilerStateSchema,
  PlanSchema,
  ChunkSchema,
  FragmentDraftSchema,
  FragmentSchema,
  DomainDraftSchema,
  IssueSchema,
  ConflictSchema,
  ResolutionRequestSchema,
  ResolutionResponseSchema,
  DomainSpecSchema,
  FailureReasonSchema,
  INITIAL_STATE,
} from "./schema.js";

/**
 * CompilerDomain v1.1 - Fragment Pipeline Architecture
 *
 * Pipeline: Plan → Generate → Lower → Link → Verify → Emit
 *
 * Status flow:
 * idle → planning → awaiting_plan_decision
 *      → generating → awaiting_draft_decision
 *      → lowering → linking → awaiting_conflict_resolution
 *      → verifying → emitting → success | failed
 */
export const CompilerDomain = defineDomain(
  CompilerStateSchema,
  ({ state, computed, actions, expr, flow }) => {
    // ════════════════════════════════════════════════════════════════════════
    // §1 Computed Values
    // ════════════════════════════════════════════════════════════════════════

    const computedValues = computed.define({
      // Status helpers
      isIdle: expr.eq(state.status, "idle"),
      isPlanning: expr.eq(state.status, "planning"),
      isAwaitingPlanDecision: expr.eq(state.status, "awaiting_plan_decision"),
      isGenerating: expr.eq(state.status, "generating"),
      isAwaitingDraftDecision: expr.eq(state.status, "awaiting_draft_decision"),
      isLowering: expr.eq(state.status, "lowering"),
      isLinking: expr.eq(state.status, "linking"),
      isAwaitingConflictResolution: expr.eq(state.status, "awaiting_conflict_resolution"),
      isVerifying: expr.eq(state.status, "verifying"),
      isEmitting: expr.eq(state.status, "emitting"),
      isSuccess: expr.eq(state.status, "success"),
      isFailed: expr.eq(state.status, "failed"),

      // Aggregate helpers
      isTerminal: expr.or(
        expr.eq(state.status, "success"),
        expr.eq(state.status, "failed")
      ),
      isProcessing: expr.or(
        expr.eq(state.status, "planning"),
        expr.eq(state.status, "generating"),
        expr.eq(state.status, "lowering"),
        expr.eq(state.status, "linking"),
        expr.eq(state.status, "verifying"),
        expr.eq(state.status, "emitting")
      ),
      isAwaitingDecision: expr.or(
        expr.eq(state.status, "awaiting_plan_decision"),
        expr.eq(state.status, "awaiting_draft_decision"),
        expr.eq(state.status, "awaiting_conflict_resolution")
      ),

      // Retry helpers
      canRetryPlan: expr.lt(state.planAttempts, state.config.maxPlanAttempts),
      hasMoreChunks: expr.lt(state.currentChunkIndex, expr.len(state.chunks)),
    });

    const {
      isIdle,
      isPlanning,
      isAwaitingPlanDecision,
      isGenerating,
      isAwaitingDraftDecision,
      isLowering,
      isLinking,
      isAwaitingConflictResolution,
      isVerifying,
      isEmitting,
      isTerminal,
      isAwaitingDecision,
      canRetryPlan,
      hasMoreChunks,
    } = computedValues;

    // ════════════════════════════════════════════════════════════════════════
    // §2 Actions - Initialization
    // ════════════════════════════════════════════════════════════════════════

    /**
     * start - Initiates compilation pipeline
     *
     * Per SPEC §7.2: Transitions idle → planning and triggers llm:plan effect.
     * Note: ID and timestamp are passed from action input (generated by effect handler)
     */
    const { start } = actions.define({
      start: {
        description: "Start Compilation",
        input: z.object({
          id: z.string().describe("Generated ID for source input"),
          text: z.string(),
          type: z.enum(["natural-language", "code", "mixed"]).default("natural-language"),
          timestamp: z.number().describe("Timestamp when received"),
          config: z.object({
            maxPlanAttempts: z.number().optional(),
            maxDraftAttempts: z.number().optional(),
            maxLoweringRetries: z.number().optional(),
          }).optional(),
        }),
        available: isIdle,
        flow: flow.seq(
          // Store sourceInput in rawInput temporarily - effect handler will read from here
          // We use rawInput because the Builder doesn't resolve expressions inside plain objects
          flow.patch(state.rawInput).set({
            id: expr.input<string>("id"),
            type: expr.input<"natural-language" | "code" | "mixed">("type"),
            text: expr.input<string>("text"),
            timestamp: expr.input<number>("timestamp"),
          } as never),
          // Apply config overrides if provided
          flow.when(
            expr.isNotNull(expr.input("config")),
            flow.patch(state.config).set(
              expr.merge(state.config, expr.coalesce(expr.input("config"), expr.lit({}))) as never
            )
          ),
          // Transition to planning - effect triggered by effect loop
          flow.patch(state.status).set("planning")
        ),
      },
    });

    // ════════════════════════════════════════════════════════════════════════
    // §3 Actions - Plan Phase
    // ════════════════════════════════════════════════════════════════════════

    /**
     * receivePlan - Receives plan from LLM
     */
    const { receivePlan } = actions.define({
      receivePlan: {
        description: "Receive Plan from LLM",
        input: z.object({
          plan: PlanSchema,
          chunks: z.array(ChunkSchema),
        }),
        available: isPlanning,
        flow: flow.seq(
          flow.patch(state.plan).set(expr.input("plan") as never),
          // Store chunks from handler input
          flow.patch(state.chunks).set(expr.input("chunks") as never),
          flow.patch(state.planAttempts).set(expr.add(state.planAttempts, 1)),
          flow.patch(state.status).set("awaiting_plan_decision")
        ),
      },
    });

    /**
     * acceptPlan - Accept plan and proceed to generation
     */
    const { acceptPlan } = actions.define({
      acceptPlan: {
        description: "Accept Plan",
        input: z.object({}),
        available: isAwaitingPlanDecision,
        flow: flow.seq(
          // Reset chunk index
          flow.patch(state.currentChunkIndex).set(0),
          // Transition to generating - effect triggered by effect loop
          flow.patch(state.status).set("generating")
        ),
      },
    });

    /**
     * rejectPlan - Reject plan and retry or fail
     */
    const { rejectPlan } = actions.define({
      rejectPlan: {
        description: "Reject Plan",
        input: z.object({
          reason: z.string(),
        }),
        available: isAwaitingPlanDecision,
        flow: flow.seq(
          // Check if can retry
          flow.when(
            canRetryPlan,
            // Retry planning - effect triggered by effect loop
            flow.patch(state.status).set("planning"),
            // Max attempts exceeded
            flow.seq(
              flow.patch(state.status).set("failed"),
              flow.patch(state.failureReason).set("MAX_PLAN_ATTEMPTS_EXCEEDED")
            )
          )
        ),
      },
    });

    // ════════════════════════════════════════════════════════════════════════
    // §4 Actions - Generate Phase
    // ════════════════════════════════════════════════════════════════════════

    /**
     * receiveFragmentDraft - Receives fragment draft from LLM
     */
    const { receiveFragmentDraft } = actions.define({
      receiveFragmentDraft: {
        description: "Receive Fragment Draft from LLM",
        input: z.object({
          draft: FragmentDraftSchema,
        }),
        available: isGenerating,
        flow: flow.seq(
          // Store draft
          flow.patch(state.fragmentDrafts).set(
            expr.append(state.fragmentDrafts, expr.input("draft")) as never
          ),
          // Transition to awaiting decision
          flow.patch(state.status).set("awaiting_draft_decision")
        ),
      },
    });

    /**
     * acceptDraft - Accept draft and continue
     */
    const { acceptDraft } = actions.define({
      acceptDraft: {
        description: "Accept Fragment Draft",
        input: z.object({
          draftId: z.string(),
        }),
        available: isAwaitingDraftDecision,
        flow: flow.seq(
          // Increment chunk index first
          flow.patch(state.currentChunkIndex).set(expr.add(state.currentChunkIndex, 1)),
          // Check if we've processed all chunks
          // After incrementing, if currentChunkIndex >= chunks.length, we're done
          // We check this by comparing the NEW value with chunks.length
          // Since we just incremented, the new value is (old + 1)
          // So we check: (old + 1) >= length, which means old >= length - 1
          // Equivalently: old + 1 < length means there are more chunks
          flow.when(
            // Note: This expression uses the OLD currentChunkIndex value
            // After incrementing from N to N+1, check if N+1 < length
            expr.lt(expr.add(state.currentChunkIndex, 1), expr.len(state.chunks)),
            // Generate next chunk (currentChunkIndex now points to next)
            flow.patch(state.status).set("generating"),
            // All chunks done, start lowering
            flow.patch(state.status).set("lowering")
          )
        ),
      },
    });

    /**
     * rejectDraft - Reject draft and retry
     */
    const { rejectDraft } = actions.define({
      rejectDraft: {
        description: "Reject Fragment Draft",
        input: z.object({
          draftId: z.string(),
          reason: z.string(),
        }),
        available: isAwaitingDraftDecision,
        // Just set status - effect loop will trigger llm:generate
        flow: flow.patch(state.status).set("generating"),
      },
    });

    // ════════════════════════════════════════════════════════════════════════
    // §5 Actions - Pipeline Phase (Lowering → Linking → Verifying → Emitting)
    // ════════════════════════════════════════════════════════════════════════

    /**
     * receiveLoweredFragments - Receives lowered fragments from PassLayer
     */
    const { receiveLoweredFragments } = actions.define({
      receiveLoweredFragments: {
        description: "Receive Lowered Fragments",
        input: z.object({
          fragments: z.array(FragmentSchema),
          issues: z.array(IssueSchema).optional(),
          hasErrors: z.boolean().default(false),
        }),
        available: isLowering,
        flow: flow.seq(
          flow.patch(state.fragments).set(expr.input("fragments") as never),
          // Store issues if any
          flow.when(
            expr.isNotNull(expr.input("issues")),
            flow.patch(state.issues).set(expr.input("issues") as never)
          ),
          // Check for errors using input flag
          flow.when(
            expr.input<boolean>("hasErrors"),
            // Lowering failed
            flow.seq(
              flow.patch(state.status).set("failed"),
              flow.patch(state.failureReason).set("LOWERING_FAILED")
            ),
            // Proceed to linking - effect loop will trigger linker:link
            flow.patch(state.status).set("linking")
          )
        ),
      },
    });

    /**
     * receiveLinkResult - Receives link result from Linker
     */
    const { receiveLinkResult } = actions.define({
      receiveLinkResult: {
        description: "Receive Link Result",
        input: z.object({
          domainDraft: DomainDraftSchema.nullable(),
          conflicts: z.array(ConflictSchema).optional(),
          pendingResolution: ResolutionRequestSchema.nullable().optional(),
          hasConflicts: z.boolean().default(false),
        }),
        available: isLinking,
        flow: flow.seq(
          // Check for conflicts using input flag
          flow.when(
            expr.input<boolean>("hasConflicts"),
            // Has conflicts - request resolution
            flow.seq(
              flow.patch(state.conflicts).set(
                expr.coalesce(expr.input("conflicts"), expr.lit([])) as never
              ),
              flow.patch(state.pendingResolution).set(expr.input("pendingResolution") as never),
              flow.patch(state.status).set("awaiting_conflict_resolution")
            ),
            // No conflicts - store draft and verify (effect loop triggers verifier:verify)
            flow.seq(
              flow.patch(state.domainDraft).set(expr.input("domainDraft") as never),
              flow.patch(state.status).set("verifying")
            )
          )
        ),
      },
    });

    /**
     * resolveConflict - Resolve a conflict
     */
    const { resolveConflict } = actions.define({
      resolveConflict: {
        description: "Resolve Conflict",
        input: z.object({
          response: ResolutionResponseSchema,
          timestamp: z.number(),
        }),
        available: isAwaitingConflictResolution,
        flow: flow.seq(
          // Record resolution - append to history
          // Note: Complex object construction requires `as never` due to builder type limitations
          flow.patch(state.resolutionHistory).set(
            expr.append(
              state.resolutionHistory,
              expr.lit({}) as never  // Placeholder - actual record constructed at runtime by effect handler
            ) as never
          ),
          // Clear pending
          flow.patch(state.pendingResolution).set(expr.lit(null) as never),
          flow.patch(state.conflicts).set(expr.lit([]) as never),
          // Re-link with resolution applied - effect loop triggers linker:link
          flow.patch(state.status).set("linking")
        ),
      },
    });

    /**
     * receiveVerification - Receives verification result
     */
    const { receiveVerification } = actions.define({
      receiveVerification: {
        description: "Receive Verification Result",
        input: z.object({
          valid: z.boolean(),
          issues: z.array(IssueSchema),
        }),
        available: isVerifying,
        flow: flow.seq(
          // Store issues
          flow.patch(state.issues).set(
            expr.append(state.issues, expr.input("issues")) as never
          ),
          // Check validity
          flow.when(
            expr.input<boolean>("valid"),
            // Valid - emit (effect loop triggers emitter:emit)
            flow.patch(state.status).set("emitting"),
            // Invalid - fail
            flow.seq(
              flow.patch(state.status).set("failed"),
              flow.patch(state.failureReason).set("VERIFICATION_FAILED")
            )
          )
        ),
      },
    });

    /**
     * receiveEmitted - Receives emitted DomainSpec
     */
    const { receiveEmitted } = actions.define({
      receiveEmitted: {
        description: "Receive Emitted DomainSpec",
        input: z.object({
          domainSpec: DomainSpecSchema,
        }),
        available: isEmitting,
        flow: flow.seq(
          flow.patch(state.domainSpec).set(expr.input("domainSpec") as never),
          flow.patch(state.status).set("success")
        ),
      },
    });

    // ════════════════════════════════════════════════════════════════════════
    // §6 Actions - Terminal
    // ════════════════════════════════════════════════════════════════════════

    /**
     * fail - Fail compilation
     */
    const { fail } = actions.define({
      fail: {
        description: "Fail Compilation",
        input: z.object({
          reason: FailureReasonSchema,
        }),
        available: expr.not(isTerminal),
        flow: flow.seq(
          flow.patch(state.status).set("failed"),
          flow.patch(state.failureReason).set(expr.input("reason") as never)
        ),
      },
    });

    /**
     * reset - Reset to idle state
     */
    const { reset } = actions.define({
      reset: {
        description: "Reset Compiler",
        input: z.object({}),
        available: expr.or(isTerminal, isAwaitingDecision),
        flow: flow.seq(
          // Reset all state to initial
          flow.patch(state.sourceInput).set(expr.lit(null) as never),
          flow.patch(state.plan).set(expr.lit(null) as never),
          flow.patch(state.planAttempts).set(0),
          flow.patch(state.chunks).set(expr.lit([]) as never),
          flow.patch(state.currentChunkIndex).set(0),
          flow.patch(state.fragmentDrafts).set(expr.lit([]) as never),
          flow.patch(state.draftAttempts).set(expr.lit({}) as never),
          flow.patch(state.fragments).set(expr.lit([]) as never),
          flow.patch(state.domainDraft).set(expr.lit(null) as never),
          flow.patch(state.conflicts).set(expr.lit([]) as never),
          flow.patch(state.pendingResolution).set(expr.lit(null) as never),
          flow.patch(state.resolutionHistory).set(expr.lit([]) as never),
          flow.patch(state.issues).set(expr.lit([]) as never),
          flow.patch(state.status).set("idle"),
          flow.patch(state.domainSpec).set(expr.lit(null) as never),
          flow.patch(state.failureReason).set(expr.lit(null) as never)
        ),
      },
    });

    // ════════════════════════════════════════════════════════════════════════
    // §7 Return Domain Output
    // ════════════════════════════════════════════════════════════════════════

    return {
      computed: computedValues,
      actions: {
        start,
        receivePlan,
        acceptPlan,
        rejectPlan,
        receiveFragmentDraft,
        acceptDraft,
        rejectDraft,
        receiveLoweredFragments,
        receiveLinkResult,
        resolveConflict,
        receiveVerification,
        receiveEmitted,
        fail,
        reset,
      },
    } as ReturnType<Parameters<typeof defineDomain>[1]>;
  },
  {
    id: "manifesto:compiler",
    version: "1.1.0",
    meta: {
      name: "Compiler Domain v1.1",
      description:
        "Fragment Pipeline architecture - Plan → Generate → Lower → Link → Verify → Emit",
    },
  }
);

export { INITIAL_STATE };
